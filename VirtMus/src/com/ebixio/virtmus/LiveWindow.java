/*
 * LiveWindow.java
 *
 * Copyright (C) 2006-2007  Gabriel Burca (gburca dash virtmus at ebixio dot com)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

package com.ebixio.virtmus;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.MemoryImageSource;
import java.awt.image.RenderedImage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;
import javax.swing.ImageIcon;
import org.openide.util.NbPreferences;

/**
 *
 * @author  gburca
 */
public class LiveWindow extends javax.swing.JFrame {
    Rectangle displaySize = new Rectangle(Utils.getScreenSize());
//    Rectangle displaySize = new Rectangle(1200, 800);

    
    /** Creates new form LiveWindow */
    public LiveWindow() {
        initComponents();
        this.setSize(displaySize.width, displaySize.height);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {

        panel = new LivePanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setBackground(new java.awt.Color(102, 255, 51));
        setForeground(new java.awt.Color(255, 102, 0));
        setResizable(false);
        setUndecorated(true);
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        panel.setBackground(new java.awt.Color(255, 204, 255));

        javax.swing.GroupLayout panelLayout = new javax.swing.GroupLayout(panel);
        panel.setLayout(panelLayout);
        panelLayout.setHorizontalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 420, Short.MAX_VALUE)
        );
        panelLayout.setVerticalGroup(
            panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        // TODO add your handling code here:
        if (evt.getKeyCode() == KeyEvent.VK_ESCAPE) {
            this.dispose();
        } else {
            ((LivePanel)panel).keyPressed(evt);
        }
    }//GEN-LAST:event_formKeyPressed
    
    public void setLiveSong(Song song) {
        ((LivePanel)panel).setSong(song);
    }
    public void setLiveSong(Song song, MusicPage startingPage) {
        ((LivePanel)panel).setSong(song, startingPage);
    }
    public void setPlayList(PlayList playList) {
        ((LivePanel)panel).setPlayList(playList);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new LiveWindow().setVisible(true);
            }
        });
    }

   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel panel;
    // End of variables declaration//GEN-END:variables
    
    
    public class LivePanel extends javax.swing.JPanel implements ActionListener {
        private Song song = null;
        
        private int page = 0;
        private float pageShift = 0.0F;     // How far the page is advanced from the top-left
        private float pageIncrement;        // By how much to advance the page at a time (in %)
        private boolean pageShiftNeeded;
        private AffineTransform xform = MainApp.screenRot.getTransform(displaySize.getSize());
        private boolean fullyPainted = false;
        
        final int maxPrevCache = 3;
        final int maxNextCache = 4;
        Hashtable<Integer, BufferedImage> pageCache = new Hashtable<Integer, BufferedImage>(3);
        Vector<Integer> toBeRendered = new Vector<Integer>(3);
        boolean waitingForImage = false;
        
        // Transparent mouse cursor
        int[] pixels = new int[16 * 16];
        Image mouseImage = Toolkit.getDefaultToolkit().createImage(new MemoryImageSource(16, 16, pixels, 0, 16));
        Cursor transparentCursor = Toolkit.getDefaultToolkit().createCustomCursor(mouseImage, new Point(0,0), "invisibleCursor");
        
        public LivePanel() {
            super();
            
            addMouseListener(new MouseAdapter() {
                public void mousePressed(MouseEvent e) {
                    if (e.getButton() == MouseEvent.BUTTON1) {
                        showNextSection();
                    } else {
                        showPrevSection();
                    }
                }
            });
            
            pageIncrement = Float.parseFloat( NbPreferences.forModule(MainApp.class).get(MainApp.OptPageScrollAmount, "100") ) / 100;
            if (pageIncrement == 0) {
                pageShiftNeeded = false;
            } else {
                pageShiftNeeded = true;
            }

            this.setCursor(transparentCursor);
            showPage(page);
        }
        
        public void keyPressed(java.awt.event.KeyEvent evt) {
            switch(evt.getKeyCode()) {
                case KeyEvent.VK_F5:
                    // TODO: This does not work. A new window is created instead...
                case KeyEvent.VK_1:
                    showFirstPage();
                    break;
                case KeyEvent.VK_PAGE_UP:
                    showPrevPage();
                    break;
                case KeyEvent.VK_PAGE_DOWN:
                case KeyEvent.VK_SPACE:
                    showNextPage();
                    break;
                default:
                    showNextSection();
                    break;
            }
        }
        
        public void showNextPage() {
            if (page < song.pageOrder.size() - 1) {
                page++;
                pageShift = page;
                showPage(page);
            }
        }
        public void showPrevPage() {
            if (page > 0) {
                page--;
                pageShift = page;
                showPage(page);
            }
        }
        public void showFirstPage() {
            page = 0;
            pageShift = 0;
            showPage(page);
        }
        
        public void showNextSection() {
            if (!pageShiftNeeded) {
                showNextPage();
            } else {
                pageShift += pageIncrement;
                // Don't allow the user to scroll beyond the last page
                if (pageShift > (song.pageOrder.size() - 1)) {
                    pageShift = (song.pageOrder.size() - 1);
                }
                page = (int)Math.floor(pageShift);
                showPage(page);
            }
        }
        public void showPrevSection() {
            if (!pageShiftNeeded) {
                showPrevPage();
            } else {
                pageShift -= pageIncrement;
                if (pageShift < 0) { pageShift = 0; }
                page = (int)Math.floor(pageShift);
                showPage(page);
            }
        }
        
        public void paint(Graphics gOld) {
            Graphics2D g = (Graphics2D)gOld;
            
            if (pageShiftNeeded) {
                if (MainApp.scrollDir == MainApp.ScrollDir.Vertical) {
                    paintShiftedVertical(g);
                } else {
                    paintShiftedHorizontal(g);
                }
                return;
            } else {
                paintRegular(g);
            }
        }
        
        public void paintRegular(Graphics2D g) {
            BufferedImage img = pageCache.get(page);
            AffineTransform origXform = g.getTransform();
            g.setTransform(xform);
            Dimension d = MainApp.screenRot.getSize(displaySize.getSize());
            
            g.setColor(Color.BLACK);
            g.fillRect(0, 0, d.width, d.height);

            if (img == null) {
                g.setColor(Color.WHITE);
                g.drawString("Loading...", d.width/2, d.height/2);
            } else {
                Point p = Utils.centerItem(new Rectangle(d), new Rectangle(img.getWidth(), img.getHeight()));
                g.drawImage(img, p.x, p.y, img.getWidth(), img.getHeight(), this);
            }
            
            g.setTransform(origXform);            
        }
        
        public void paintShiftedVertical(Graphics2D g) {
            int heightPainted = 0;
            BufferedImage img1 = pageCache.get(page);
            AffineTransform origXform = g.getTransform();
            g.setTransform(xform);
            
            Dimension d = MainApp.screenRot.getSize(displaySize.getSize());
            g.setColor(Color.BLACK);
            g.fillRect(0, 0, d.width, d.height);

            if (img1 != null) {
                
                float page1Shift = pageShift - page;

                int img1y = Math.round(img1.getHeight() * page1Shift);
                g.drawImage(img1, 0, -img1y, img1.getWidth(), img1.getHeight(), Color.BLACK, this);
                heightPainted += img1.getHeight() - img1y;
                
                BufferedImage img2 = pageCache.get(page + 1);
                if (img2 != null) {
                    int img2y = img1.getHeight() - img1y;
                    g.drawImage(img2, 0, img2y, img2.getWidth(), img2.getHeight(), this);
                    heightPainted += img2.getHeight();
                    
                    BufferedImage img3 = pageCache.get(page + 2);
                    if (img3 != null) {
                        int img3y = img1.getHeight() - img1y + img2.getHeight();
                        g.drawImage(img3, 0, img3y, img3.getWidth(), img3.getHeight(), this);
                        heightPainted += img3.getHeight();
                    }
                }
            } else {
                g.setColor(Color.WHITE);
                g.drawString("Loading...", d.width/2, d.height/2);
            }
            
            fullyPainted = heightPainted > d.height ? true : false;
            
            g.setTransform(origXform);
        }
        
        public void paintShiftedHorizontal(Graphics2D g) {
            int widthPainted = 0;
            BufferedImage img1 = pageCache.get(page);
            AffineTransform origXform = g.getTransform();
            g.setTransform(xform);

            Dimension d = MainApp.screenRot.getSize(displaySize.getSize());
            g.setColor(Color.BLACK);
            g.fillRect(0, 0, d.width, d.height);

            if (img1 != null) {
                float page1Shift = pageShift - page;
                
                int img1x = Math.round(img1.getWidth() * page1Shift);
                g.drawImage(img1, -img1x, 0, img1.getWidth(), img1.getHeight(), Color.BLACK, this);
                widthPainted += img1.getWidth() - img1x;
                
                BufferedImage img2 = pageCache.get(page + 1);
                if (img2 != null) {
                    int img2x = img1.getWidth() - img1x;
                    g.drawImage(img2, img2x, 0, img2.getWidth(), img2.getHeight(), this);
                    widthPainted += img2.getWidth();
                    
                    BufferedImage img3 = pageCache.get(page + 2);
                    if (img3 != null) {
                        int img3x = img1.getWidth() - img1x + img2.getWidth();
                        g.drawImage(img3, img3x, 0, img3.getWidth(), img3.getHeight(), this);
                        widthPainted += img3.getWidth();
                    }
                }
            } else {
                g.setColor(Color.WHITE);
                g.drawString("Loading...", d.width/2, d.height/2);
            }
            
            fullyPainted = widthPainted > d.width ? true : false;
            g.setTransform(origXform);
        }
        
        private void cleanCache() {
            cleanCache(page);
        }
        private void cleanCache(int currentPage) {
            int lastPage = 0;
            
            for (int i = 0; i < currentPage - maxPrevCache; i++) {
                if (pageCache.containsKey(i)) {
                    pageCache.remove(i);
                    MainApp.log("LiveWindow: removed page " + i);
                }
            }
            for (int i: pageCache.keySet()) {
                if (i > lastPage) lastPage = i;
            }
            for (int i = currentPage + maxNextCache + 1; i < lastPage; i++) {
                if (pageCache.containsKey(i)) {
                    pageCache.remove(i);
                    MainApp.log("LiveWindow: removed page " + i);
                }
            }
        }
        
        private void repopulateCache(int page) {
            if (song == null) return;
            int range = Math.max(maxPrevCache, maxNextCache);
            toBeRendered.clear();
            
            if (!pageCache.containsKey(page)) toBeRendered.add(page);
            
            // Render closest pages first, then next removed, etc...
            for (int i = 1; i <= range; i++) {
                if (i <= maxNextCache && !pageCache.containsKey(page + i)) {
                    if (page + i < song.pageOrder.size()) toBeRendered.add(page + i);
                }
                if (i <= maxPrevCache && !pageCache.containsKey(page - i)) {
                    if (page - i >= 0) toBeRendered.add(page - i);
                }
            }
            
            renderNext();
        }
        
        public void actionPerformed(ActionEvent e) {
            waitingForImage = false;
            if (song == null) return;
            
            BufferedImage img = ((MusicPage)e.getSource()).getRenderedImage(this);
            ByteArrayInputStream is = new ByteArrayInputStream(e.getActionCommand().getBytes());
            if (is.available() > 0) {
                Properties props = new Properties();
                try {
                    props.loadFromXML(is);
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
                int pg = Integer.parseInt( props.getProperty("page", "-1") );
                if (pg >= 0 && 
                    Integer.parseInt(props.getProperty("requesterID", "0")) == this.hashCode()) {
                    pageCache.put(pg, img);
                    if (pg == page || !fullyPainted) {
                        repaint();
                    }
                }
            }
            cleanCache();
            renderNext();
        }
        
        private void renderNext() {
            if (song == null || waitingForImage) return;
            if (toBeRendered.size() > 0) {
                int newPage = toBeRendered.remove(0);
                if (newPage < 0 || newPage >= song.pageOrder.size()) return;
                Properties props = new Properties();
                props.setProperty("requesterID", Integer.toString(this.hashCode()));
                props.setProperty("page", Integer.toString(newPage));
                props.setProperty("rotation", MainApp.Rotation.Clockwise_0.toString());
                props.setProperty("fillSize", Boolean.toString(false));
                
                song.pageOrder.get(newPage).requestRendering(this, Math.abs(page - newPage),
                        MainApp.screenRot.getSize(displaySize.getSize()), props);
                this.waitingForImage = true;
            }            
        }

        private void showPage(int page) {
            cleanCache(page);
            repopulateCache(page);
            this.repaint();
        }        
        
        private void setSong(Song song) {
            if (song.pageOrder.size() == 0) return;
            setSong(song, song.pageOrder.firstElement());
        }
        private void setSong(Song song, MusicPage startingPage) {
            this.song = song;
            page = song.pageOrder.indexOf(startingPage);
            this.pageCache.clear();
            this.toBeRendered.clear();
            MusicPage.cancelRendering(this);

            showPage(page);
        }

        private void setPlayList(PlayList playList) {
            Song s = new Song();
            for (Song plSong: playList.songs) {
                for (MusicPage mp: plSong.pageOrder) s.pageOrder.add(mp);
            }
            setSong(s);
        }

    }
}
